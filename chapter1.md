# 第一章：硬盘与分区操作

之所以把硬盘放在第一章是因为对于大多数用户来说硬盘是他们能独立操 作的第一个硬件，相对于CPU、内存、显卡等部件硬盘的操作要简单的多，此 外硬盘故障也是最常见的电脑故障之一。

### 硬盘与硬盘分区

刚刚买来的新硬盘是不能直接使用的，需要经过初始化和分区操作，这个过程 就是将硬盘物理上分成若干个不同的区域方便计算机调度和使用。通常，我们所说的C盘就是指的一个分区，当然在之后我们会说，有时候不是分区。用通俗的话来说，给硬盘分区就好像把一个大房子分成若干个房间。

**等等，之前不是说要先初始化的吗？初始化是干什么的呢？**

所谓初始化，套用上面的例子就是给每个房间贴上房间号，然后在大门口贴上一个表，1号房间往左走第一个，占地15平方米；2号第二个...这个表就是分区表。从刚才的例子上可以看出，分区表不属于任何分区，是硬盘上独立的一块区域，在“我的电脑”中是看不到分区表什么的，所以也不会出现删除分区表什么的情况。

那么我们继续说分区表的问题，由于大家的房子都不一样（硬盘种类和型号太多了），那分区表肯定就不一样了，但分区表要按格式写啊，不然没人看得懂是不。分区表的格式非常重要，因为如果格式错误那电脑就找不到正确的分区了，也就不能从硬盘上读取数据了。

硬盘的分区表通常有两类：**MBR和GPT**，无数小白会载在这俩分区表的转换上。

### MBR分区表：经典4分区

我们刚才说过，硬盘的分区表是不属于任何分区的，那么就有一个问题了：分区数量越多，分区表就越大；分区表越大，第一分区就要越往后移动（分区表在第一分区的前面），那么第一分区该往后移动多少呢？为了解决这个问题，干脆就把分区表长度弄成固定的，但是这样分区数量就会有上限。

MBR分区表比较短（64个字节），最大只能存四个分区（MBR分区表的格式中一个分区的信息占用16字节），所以**MBR分区表最大只能分四个区**。那问题又来了，如果我要使用超过4个分区咋办呢？

你还记得我们刚才的类比吗？硬盘比作房子的话，分区是房间，那么房间内还可以再分成房间吗？可以，这就是**扩展分区**，扩展分区又分成的小分区叫做**逻辑驱动器**（又称**逻辑分区**）。扩展分区就是专门为了使MBR分区能超过4个来准备的。但是扩展分区内再分成小分区的方式可是和硬盘分成分区的方式不一样的。这是为啥呢？因为如果套用硬盘的分区模式，也就是在扩展分区的开端处再来一个类似分区表的结构，那一个扩展分区是不是又只能分成有限个逻辑分区了？

扩展分区这个大房间里是没有玄关的，每个小房间的信息直接写在每个房间的门牌号上，这个东西叫做扩展分区表。在每一个逻辑驱动器的扩展分区表都记录了这个逻辑驱动器数据区的起始位置（就是能用来存东西的区域）和下一个逻辑驱动器的扩展分区表位置。也就是说，一个扩展分区里有几个逻辑驱动器就会有几个扩展分区表。这样的好处是，扩展分区理论上可以分成无限个逻辑驱动器，彻底够用了吧。但是，需要注意的是，**MBR分区表中只允许一个分区作为扩展分区使用**，剩下的三个叫做主分区，主分区是不可再分的。

注意，扩散分区必须划分了逻辑驱动器才能使用，扩展分区中未划分逻辑驱动器的部分不会被使用。

硬盘读取分区数据时，只需要从读入分区表然后分区表中记录了四个分区的位置、数据区起始等各种信息；而当硬盘从扩展分区读取逻辑驱动器的位置时，是这样的：硬盘先从扩展分区的头部找到第一个逻辑驱动器的扩展分区表，从这里读取第一个逻辑驱动器的信息和第二个逻辑驱动器的扩展分区表的位置，然后根据这个位置找到第二个逻辑驱动器的扩展分区表......直到没有下一个扩展分区表。

除了涉及到操作系统启动时外，基本上可以认为逻辑驱动器和主分区在使用时是没有区别的。在windows系统中，主分区和逻辑驱动器统一视为卷。回到开头的话题，你能从“我的电脑”中看到的驱动器，一定是卷，通常要么是主分区要么是逻辑驱动器，置于更复杂的卷，将会在之后逐步解释。

### GPT分区表：简单暴力够用

GPT分区表是为了替代MBR分区表而诞生的，为什么要替换MBR分区表呢？因为MBR分区表有两个大缺陷，其一刚刚我们已经提到了就是只能有四个分区，其二嘛就是最大只能支持2TB的硬盘。这是因为MBR分区表只有64字节大小，来记录地址的话最大只能到大约2.2TB。

GPT分区表就大多了，它最多能支持128个分区，单个分区可以支持18EB大小（1EB=1048576TB），而且GPT分区方案中所有分区都是主分区，不再有扩展分区了，也就不再有逻 辑驱动器或者逻辑分区了。

不过，不是说这128个分区都能用的，因为GPT分区通常需要一个EFI分区来引导系统，这个我们之后会提。此外，对于windows系统来说，能直接访问的分区不超过26个，不然就没有盘符了，但是对于ntfs分区你可以把它装入另一个ntfs分区的文件夹内，这样来实现访问超过26个分区。啥？ntfs分区是啥？往下看。

### 格式化：硬盘分区的种类

无论使用MBR还是GPT来进行分区，分区后我们都要对每个分区（或逻辑驱 动器）执行格式化才能用它来存储数据。我们可以把分区理解为一个屋子分割成几个房间，而格式化就是装修房间，不同的装修方式显然会带来很大的影响，所以在格式化的时候我们需要选择不同的分区类型，目前常见的分区类 型主要有以下几类：

**FAT32**分区，常见于U盘和小硬盘分区。FAT32的兼容性非常好，但是有一个致命的缺点就是FAT32分区中单文件大小不能超过4GB。这也是很多人抱怨明明硬盘空间足够但是复制文件时却提示文件空间大小不足的原因。此外，windows系统自带的分区工具不能将超过32GB的分区格式化为FAT32分区，使用其他分区工具可以创建大得多的FAT32分区，理论上FAT32分区最大支持2TB的单分区。在一些系统中也将FAT32称为FAT。

**NTFS**。NTFS是微软推出的新一代硬盘分区，NTFS最大的特点是没有单文件大小上限（单文件大小上限达到分区容量上限，2TB），非常适合用来做大分 区。该分区的安全性也比FAT32有了极大提高，从windows Vista开始， windows系统必须安装在NTFS分区上。需要注意的是NTFS分区的知识产权在微软手里，所以非微软的操作系统，如Linux，macOS等都不能直接读写NTFs分区，这会对多系统用户造成一定的麻烦。

**exFAT**是增强版的FAT32。exFAT单文件大小达到了16EB（理论值），适用于大U盘。该分区在Linux和macOS中兼容性都很好，非常适合在不同系统之间迁移数据。windowsXP需要安装exFAT补丁才能识别exFAT分区。

非windows系统采用的分区格式将会在其他章节叙述。

### 数据恢复：硬盘是如何存储数据的

硬盘保存数据可不能像我们平时堆东西那么简单，因为这样的话我们要从硬盘中找一个东西出来就要翻遍整个硬盘才行。实际上硬盘在保存文件的时候还要给每个文件列一个目录，这个目录放在每个卷的最前方，叫做**文件分配表，简称FAT表**。当硬盘要读取数据时会先在FAT表中找这些文件对应的区域在哪，然后直接从这些区域把数据读出来；当需要写入数据时也是从FAT表中读出来哪里有空位，然后将数据写入空白处。

唯一的不同在于删除操作。当硬盘需要删除一个文件时他并不会根据FAT表找到这个文件的区域然后覆盖掉整个文件，而是直接在FAT表中将这个文件的目录删掉完事。这样当以后需要写入新的数据时，FAT表已经将此处标记为空白，硬盘直接用新数据覆盖老数据就可以了。这也是为什么硬盘删除东西要比写入东西快得多的缘故。

由此，我们可以发现，**操作系统不能真正删除数据**。如果我们赶在硬盘覆盖这些数据之前，跳过FAT表直接来检索整个硬盘，那么这些数据还是可以找回来的，这就是数据恢复的基本原理。不过对于已经覆盖的数据，该方法就没有什么用了。

### 打包：同样大小文件为什么拷贝速度不同

大家可能都有这样的体验，拷贝一个10GB的电影要比拷贝一个10000个1M的图片快得多，这是为什么呢？这是因为硬盘读写的时候每次都要从FAT表找空间，还要写入FAT表，10000个文件就要额外找好多次空间，多谢N次FAT表（以为文件在硬盘上不一定是连续的，一个文件的FAT表可能分好几段），所以拷贝散文件需要的读写就更加频繁。另外，对于更小的文件，还涉及到硬盘分区的最小单位问题。

在格式化的时候通常是要选择簇大小的，这个**簇大小就是硬盘中最小的数据单位**，所有的文件都只能占据整数个簇。比如簇大小为16KB时，保存一个1KB的文件也要占用16KB的硬盘空间，保存一个17KB的就要占用两个。如果有很多零散的文件也会因为簇大小的问题导致更加频繁的读写。比如说160M的单文件在16K的簇大小时需要占用1024个簇，但是如果都是很小的散文件可能就要占用远多于1024个簇，这需要硬盘更加频繁的找空白写数据，导致性能下降。另外，硬盘实际上实在高速旋转的，只有当硬盘旋转到磁头对应的位置时才能进行读写。所以如果需要频繁的变更FAT表和写小文件，那硬盘很可能一整圈就没干什么活，速度当然就大打折扣了。这也是为啥机械硬盘速度与转数相关的原因。

从上面可以看出，散文件的拷贝是非常慢的，所以就有了打包等技术，一方面压缩一下文件的大小，另一方面可以将若干个小文件变成一个大文件，这样复制起来就快很多了。其中一种打包技术就是大名鼎鼎的Ghost，Ghost是将整个硬盘或者分区打包成一个文件，这样就能大大提高数据的转移效率，这也是为什么ghost安装windowsXP等老系统的时候速度远远快于微软原版的原因。后来被windows的WIM/ESD映像和macOS的dmg映像也有异曲同工的效果。

